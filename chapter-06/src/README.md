## 基础知识

### 1. 常用内存管理

- 垃圾回收(GC, Garbage Collection)，在程序运行时找到所有不再使用的内存并回收，eg: JavaScript(标记清除、引用计数等)；
- 显式的申请和释放内存，eg: C；
- 所有权系统，所有权系统规则会在编译时就被检查，任意规则不满足，程序将无法编译通过。由于是编译时检查的规则，从而不会拖慢程序运行时的性能，eg: Rust。

### 2. 堆/栈

堆和栈都可以在程序运行时给程序提供内存空间：

- 栈：先进后出，大小固定，像一叠盘子。
- 堆：大小不固定，指针寻址，像一个仓库。

在性能的赛跑中，栈就像速度迅猛的跑车，堆则更像一辆载重卡车：

- 栈的读写速度快，因为一切都井井有条，就像把盘子放在最上面那样简单。
- 而堆要先找到合适的存放空间，读取时还要通过标签（指针）找到物品，就像在杂货仓库里寻找一个小小的零件一样，可能需要多花点时间。

### 3. String 类型

**&str**

&str 为字符串字面值，它是不可变的，是硬编码到程序中的，其值在运行时保存在 Read Only Memory 中，引用保存在栈上，两个字面值相同的 &str 变量，其地址一致。

**String**

String 为可变的，其值保存在堆中，引用保存在栈上，是一个胖指针：`fat pointer`，结构为：

- pointer: heap中值的内存地址
- length: 当前值的长度、当前元素个数
- capacity: 当前缓冲区的容量，可以容纳元素的个数，当前字符串的长度超过当前分配的capacity会重新分配内存，会将当前字符串拷贝到新分配的内存中。

## 所有权

### 1. 所有权规则

- 每个值都有一个所有者；
- 一个值同时只能有一个所有者；
- 当所有者离开作用域范围，这个值将被丢弃。

```rust
fn main() {
    // 规则 1：Rust中每个值都有一个所有者
    let s1 = String::from("hello"); // s1 是值 "hello" 的所有者
    
    {
        // 规则 2：一个值同时只能有一个所有者
        let s2 = s1; // 所有权从 s1 转移到 s2（s1 不再有效）
        // println!("{}", s1); // 这会导致编译时错误，因为 s1 不再有效
        println!("{}", s2); // 这是允许的，因为 s2 现在拥有该值
    } // s2在此处超出范围

    // 规则 3：当所有者离开作用域范围，这个值将被丢弃
    // 由于 s2 超出范围，因此为值 "hello" 分配的内存在此处自动释放。
}
```

### 2. 所有权转移

对于类似 i32 这样的简单类型，赋值的时候 Rust 会自动进行拷贝（Copy）。而对于 String 这样的分配到堆上的复杂类型，发生的却是所有权的转移，而不是拷贝。

```rust
let x = 5;
let y = x;
println!("{}{}", x, y); // 5, 5

let s1 = String::from("hello");
let s2 = s1;
println!("{}{}", s1, s2); // 编译报错：cannot move out of `s1` because it is borrowed
```

### *. 函数传参与返回值

## 引用与借用

### 1. 可变引用

### 2. 不可变引用

### 3. NLL

### 4. 悬垂引用

### *. 引用规则总结

## 切片

## 1. 字符串切片

## 2. 其他切片
